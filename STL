前述：
   STL分为六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器；
   1、迭代器：扮演了容器和算法之间的胶合剂;
   2、仿函数：行为类似函数，可作为算法的某种策略；
   3、空间配置器：负责空间的配置与管理;
   
(1)容器：
一、vector
   1、创建vector模板类，要包含头文件vector，还要用<type>来表明对象的类型，以及动态分配内存，指明内存所需的矢量个数；
include<vector>
vector<int>Ratings(5);//创建int型的vector对象Ratings，里面的容量为5个时间复杂度是线性的
   2、其他成员函数
size()--返回容器内的元素个数
swap()--交换两个容器的内容，作用:可以压缩内存空间，假设v原来的内存空间为100，大小为3，
        当使用vector<int>(v).swap(v)时，v的大小和容量都是一样的，为3；
        vector<int>(v)为匿名对象,指向v原来的空间，当这行代码执行完之后，系统会回收匿名对象指向的空间  
begin()--返回指向容器中第一个元素的迭代器
end()--返回一个表示超过容器尾的迭代器
erase()--删除矢量中给定区间的元素，因此接受两个迭代器的参数   
insert()--与erase()的相反，但接受三个迭代器的参数，第一个是指定新元素的插入位置，后两个指定是插入位置的区间
push_back(val)--在内存空间尾部插入元素val
pop_back()--数据尾部进行删除数据
reserve(int len)--预留len个空间，使用在数据比较大时;

   3、其他操作函数
   for_each(迭代器1，迭代器2，函数(输出函数名));//该函数可以在迭代器1和迭代器2之间输出容器的内容
   sort(迭代器1，迭代器2);//该函数可以按两个迭代器之间的元素进行排序，但必须要重载符号函数，operator函数,
或：sort(迭代器1，迭代器2，函数);//排序根据函数的参数类型来进行，如果没有这个函数，则默认调用operator函数
   random_shuffle(迭代器1，迭代器2);// 随机排序
   4、当原内存的空间不够时，会新开辟比原来大两倍的空间 
   5、容器嵌套：vector<vector<int>>v;//相当于二维数组，赋值时先对内进行赋值，再对外进行赋值，用push_back()；
   输出时：两个for循环；
   for (vector<vector<int>>::iterator It = v.begin(); It != v.end(); It++)
		{
			//（*It）是容器 vector<int>
			for (vector<int>::iterator it = (*It).begin(); it != (*It).end(); it++)
			{
				//因为是内嵌容器，因此先遍历内容器，则是由容器（*It）指向
				cout << (*it) << " ";
			}
			cout << endl;
		}
 缺点：头部插入删除效率低，数据量越大，效率越低。
二、stack 栈
  简概：栈是一种”先进后出“的数据结构，只有一个出口，用push进行压栈和pop进行出栈
在C++中使用栈，需要包含头文件 stack,同时还要包含使用哪种容器作为底层容器。不允许遍历，不允许随机访问栈
例如：使用list作为底层容器
#include<list>
#include<stack>
....


使用：
  stack<int,list<int>>istack;//
  istack.push(元素)；//压栈
  istack.pop();//出栈，删除栈顶的元素
  istack.top();//将栈顶输出
  istack.size();//求出栈的大小
  bool.empty()const;//判空
相比C中，使用STL的栈更加方便，程序更加简便  
  
 三、deque
  是双端队列(或者数组),内部含有中控器，用来管理缓冲区的地址，缓冲区用来存放真实的数据；
  deque可以随机访问。
  deque的构造方式跟vector差不多
  其他操作函数也差不多，另外：
  deque.empty()//判空
  deque.size()//vector也有，返回容器中元素的大小
  deque.resize(num)//重新指定容器的大小为num
  deque.resize(num，elem)//重新指定容器的大小为num,若容器变长，则以num值填充新位置，若变小，则删除末尾的元素
  push_back()--尾插
  push_front()--头部插
  pop_back()--删除容器最后一个数据
  pop_front()--删除第一个数据
  
  insert(pos,elem);
  insert(pos,n,elem);
  insert(pos,begin(),end());在pos位置插入区间[begin,end)的数据
  
  AAAA级别案例：
void Mark(vector<person>&v)
{
	//int Score=0;
	//deque<int>d;//不能在这里声明，因为每次调用Mark函数时，d都会重新开辟空间，而原来的数据没有释放
	              //新的数据会在原来的空间上继续存放，所以会导致，每个选手的打分次数不一样
	//cout << "分别输入5名选手的分数： " << endl;
	for (vector <person>::iterator vt = v.begin(); vt != v.end(); vt++)
	{
		deque<int>d;//必须在这里声明，这样p才会重新开辟空间属于vt当前所指向的选手
		cout << vt->m_Name << " 打分： " << endl;
		for(int i=0;i<10;i++)
		{ 
			//cin >> Score;
			int mScore = rand() % 41 + 60;//60~100
			d.push_back(mScore);
		}
		//测试代码
                for (deque<int>::iterator de = d.begin(); de!= d.end(); de++)
		{
			cout<<*de<<" ";
		}
		cout << endl;

		sort(d.begin(),d.end());//排序
		int num = 0;
		d.pop_back();//去掉最高分
		d.pop_front();//去掉最低分
		//不用删除函数
                //d.erase(d.begin());
		//d.erase(d.end());
		for (deque<int>::iterator de = d.begin(); de != d.end(); de++)
		{
			num += *de;
		}
		//Score = num / mem;
		int Score = num / d.size();
		vt->m_Score = Score;//可以用容器直接访问类中的成员，因为vt就是vector<person>，因此可以截取到m_Score进行赋值
		
	}
}
  copy()函数： copy (myints, myints+7, myvector.begin());
              //myints是数组myints的第一个元素，myints+7是最后一个元素，将之间的元素放在vector定义的容器：myvector中
  
 四、list
   list 是一个双向链表，具备前移、后移的能力，在插入操作、接合操作都不会造成原有的list失效;
在递增、递减、取值、成员取用操作时，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数值，成员取用时取用的是节点的成员
list的操作有：
push_front(),
push_back(),
erase(),//删除具体的某个元素
pop_front(),
pop_back(),//出列，从尾
clear(),//清除所有元素
remove(),//一个参数，移除元素
unique(),//在连续相同的元素时，只能出现一次，即合为单个
splice()//三个参数，接合
merge()//单个参数，合并
reverse(),//逆序
sort()//无参数 排序
transfer()//三个参数  迁移

五、queue




